Kubernetes - technologia zarzÄ…dzania i obsÅ‚ugi kontenerami (Cointainer Orchiestration). Jest teÅ¼ Docker Swarm do obsÅ‚ugi kontenerÃ³w 
ale brakuje mu zaawansowanych funkcji w zÅ‚oÅ¼onych aplikacjach.

Klaster - jest zbiorem poÅ‚Ä…czonych wÄ™zÅ‚Ã³w (nodÃ³w)
Node (Minions) - jest to wÄ™zeÅ‚ (node) ktÃ³ry jest maszynÄ… fizycznÄ… lub wirtualnÄ… na kÃ³rej zainstalowany jest Kubernetes i tam Kubernetes uruchamia kontenery 
Worker node - tworzy siÄ™ wiÄ™cej niÄ‡ jeden Node, jesli jeden node ulegnie awarii, aplikacja bÄ™dzie dostÄ™pna z innych nodÃ³w. Plus obciÄ…Å¼enie jest mniejsze.
Master Node - to kolejny node z zainstalowanych Kubernetesem, skonfigurowany jako Master. ObsÅ‚uguje nody w klastrze. 
______________________________________
              KLASTER

__________________
      Master      |    
                  |
*Kubernetes       |
__________________|
*Master Node
__________________
      Node        |    
--------------    |
Docker Kontener   |
--------------    |
*Kubernetes       |
__________________|
*Worker node
__________________
      Node        |    
--------------    |
Docker Kontener   |
--------------    |
*Kubernetes       |
__________________|
*Worker node
______ERROR________
      Node        |    
--------------    |
Docker Kontener   |
--------------    |
*Kubernetes       |
__________________|
*Worker node
______________________________________

COMPONENTY - podczas instalacji Kubernetesa instaluje siÄ™ nastÄ™pujÄ…ce komponenty:

---------------API SERVER------------------------------

API SERVER - jest to interface dla Kubernetesa tj. uÅ¼ytkownicy, urzÄ…dzenie zarzÄ…dzajÄ…ce, interface wiersza poleceÅ„. 
DziaÅ‚a jako gÅ‚Ã³wny punkt komunikacji miÄ™dzy wszystkimi elementami systemu, wszystko co siÄ™ dzieje w Klastrze przechodzi przez niego.
Przyjmuje rzÄ…dania (requests) od uÅ¼ytkownikÃ³w, narzÄ™dzi (kubectl), kontenerÃ³w i innych komponentÃ³w. Waliduje i autorycuje te rzÄ…dania,
sprawdza, czy Å¼Ä…dania sÄ… poprawne (np. czy YAML ma prawidÅ‚owÄ… strukturÄ™, czy uÅ¼ytkownik ma uprawnienia).
Zapisuje i odczutuje dane z etcd (bazy danych przechowujÄ…cej stan klastra). Zapisuje stan klastra do etcd  (bazy danych, w ktÃ³rej 
przechowywany jest aktualny stan caÅ‚ego klastra).
UdostÄ™pnia dane innym komponentom â€“ np. kubelet, scheduler czy controller manager komunikujÄ… siÄ™ z API Serverem, Å¼eby wiedzieÄ‡, co majÄ… robiÄ‡.

PrzykÅ‚ad:
1. Administrator wpisuje:
kubectl create pod --image=nginx
2. kubectl wysyÅ‚a Å¼Ä…danie do API Servera.
3. API Server:
- Sprawdza, czy uÅ¼ytkownik ma uprawnienia (RBAC, autoryzacja),
- Waliduje Å¼Ä…danie,
- Zapisuje nowy obiekt Pod w etcd.
4. Controller Manager widzi, Å¼e pojawiÅ‚ siÄ™ nowy Pod.
5. Scheduler wybiera wÄ™zeÅ‚, na ktÃ³rym Pod ma siÄ™ uruchomiÄ‡.
6. Kubelet na danym wÄ™Åºle kontaktuje siÄ™ z API Serverem, pobiera definicjÄ™ i uruchamia kontener.

-----------------etcd----------------------------
etcd - przechowuje wartoÅ›ci klucz-wartoÅ›Ä‡ uÅ¼ywanych przez Kubernetes do przechowywania wszystkich danych uÅ¼ywanych do zarzÄ…dzania klastrem. 
W etcd zapisany jest peÅ‚ny, aktualny stan wszystkiego w klastrze.
Jest odpowiedzialny za blokady w klastrze, aby upewniÄ‡ sie Å¼e nie ma konflitÃ³w miÄ™dzy Masters

PrzykÅ‚ady danych w etcd:
- definicje wszystkich PodÃ³w, DeploymentÃ³w, Serviceâ€™Ã³w, ConfigMap, itp.
- informacje o uÅ¼ytkownikach, rolach i uprawnieniach (RBAC),
- dane o statusie wÄ™zÅ‚Ã³w (Node),
- dane konfiguracyjne dotyczÄ…ce samego klastra.
MoÅ¼na to sobie wyobraziÄ‡ jak wewnÄ™trznÄ… bazÄ™ danych Kubernetes, w ktÃ³rej zapisane sÄ… wszystkie obiekty API.
Dane sÄ… trwale zapisane na dysku (nie znikajÄ… po restarcie klastra)
DostÄ™p tylko przez API Server â€“ inne komponenty nie Å‚Ä…czÄ… siÄ™ bezpoÅ›rednio z etcd.
JeÅ›li etcd siÄ™ uszkodzi lub dane zostanÄ… utracone â€” Kubernetes â€traci pamiÄ™Ä‡â€ o tym, jakie obiekty miaÅ‚y istnieÄ‡ w klastrze.
Zwykle tworzy siÄ™ kopie zapasowe (snapshoty) etcd

----------------SCHEDULER-----------------------------
SCHEDULER - przypisuje nowe Pody do konkretnych wÄ™zÅ‚Ã³w (Node) w klastrze. Decyduje, na ktÃ³rym wÄ™Åºle (Node) zostanie uruchomiony nowy Pod.
Odpowiedzialny jest za dystrybucjÄ™ pracy dla kontenerÃ³w w wielu nodach. Poszukuje nowo utworzonych kontenerÃ³w i przypisuje je do nodÃ³w kontener <=> node. 

PrzykÅ‚ad:

1. Tworzysz Pod (np. przez kubectl apply -f pod.yaml).
2. API Server zapisuje ten obiekt w etcd.
3. Scheduler zauwaÅ¼a, Å¼e Pod nie ma przypisanego wÄ™zÅ‚a (.spec.nodeName jest puste).
4. Scheduler:
- zbiera informacje o wszystkich dostÄ™pnych wÄ™zÅ‚ach,
- filtruje je, aby wyeliminowaÄ‡ te, ktÃ³re nie speÅ‚niajÄ… wymagaÅ„,
- ocenia i wybiera najlepszy wÄ™zeÅ‚.
5. Wynik (wybrany Node) przekazuje z powrotem do API Servera.
6. API Server aktualizuje obiekt Pod w etcd.
7. Kubelet na wybranym wÄ™Åºle widzi, Å¼e ma uruchomiÄ‡ ten Pod â€” i to robi.

Wynagradzanie (Scoring)
Dla wÄ™zÅ‚Ã³w, ktÃ³re przeszÅ‚y filtr, scheduler nadaje punkty wedÅ‚ug rÃ³Å¼nych algorytmÃ³w:
balansowanie obciÄ…Å¼enia,
lokalnoÅ›Ä‡ danych,
preferencje (preferredDuringScheduling),
dostÄ™pnoÅ›Ä‡ zasobÃ³w.
WÄ™zeÅ‚ z najwyÅ¼szym wynikiem wygrywa.

----------------CONTROLLER-----------------------------
CONTROLLER (Controller Manager) - jest odpowiedzialny za orchiestracjÄ™, reaguje gdy node, kontener przestajÄ… dziaÅ‚aÄ‡. Podejmuje decyzjÄ™ 
o wprowadzeniu nowych pojemnikÃ³w. 
Controller to proces, ktÃ³ry ciÄ…gle monitoruje aktualny stan klastra i porÃ³wnuje go z poÅ¼Ä…danym stanem (tym, ktÃ³ry zadeklarowaÅ‚eÅ› w YAML-u).
Ty deklarujesz, jak ma wyglÄ…daÄ‡ klaster (np. â€chcÄ™ mieÄ‡ 3 repliki Nginxaâ€).
Controller pilnuje, Å¼eby tak wÅ‚aÅ›nie byÅ‚o â€” nawet jeÅ›li coÅ› siÄ™ zepsuje.
To jest serce mechanizmu â€self-healingâ€ (samouzdrawiania) w Kubernetesie.

PrzykÅ‚ad:
1. UÅ¼ytkownik tworzy obiekt (np. Deployment z 3 replikami) przez API Server.
2. Obiekt zostaje zapisany w etcd (poÅ¼Ä…dany stan).
3. Controller Manager uruchamia odpowiedni controller (np. ReplicaSet Controller), ktÃ³ry:
-sprawdza aktualny stan (np. ile PodÃ³w naprawdÄ™ dziaÅ‚a),
-porÃ³wnuje go z poÅ¼Ä…danym stanem,
-podejmuje akcje, Å¼eby wyrÃ³wnaÄ‡ rÃ³Å¼nicÄ™ (np. tworzy brakujÄ…ce Pody).
4. Wszystko odbywa siÄ™ przez API Server â€” kontrolery nigdy nie Å‚Ä…czÄ… siÄ™ bezpoÅ›rednio z etcd.

W Kubernetesie dziaÅ‚a wiele rÃ³Å¼nych kontrolerÃ³w, kaÅ¼dy odpowiedzialny za inny rodzaj obiektÃ³w:

Kontroler	/ Odpowiada za	/ Co robi
ReplicaSet Controller	/ ReplicaSet	/ Utrzymuje zadanÄ… liczbÄ™ replik PodÃ³w
Deployment Controller	/ Deployment	/ Tworzy/aktualizuje ReplicaSet-y podczas rolloutÃ³w
DaemonSet Controller	/ DaemonSet	/ Zapewnia, Å¼e na kaÅ¼dym wÄ™Åºle dziaÅ‚a dany Pod
Job Controller	/ Job	/ Uruchamia zadania do jednorazowego wykonania
StatefulSet / Controller	/ StatefulSet	ZarzÄ…dza Podami z trwaÅ‚Ä… toÅ¼samoÅ›ciÄ… i storage
Node Controller	/ Node	/ Monitoruje stan wÄ™zÅ‚Ã³w i usuwa niedostÄ™pne
Service Controller	/ Service	/ Konfiguruje load balancing miÄ™dzy Podami
Endpoint Controller	/ Endpoints	/ Aktualizuje listÄ™ PodÃ³w w Serviceâ€™ach

KaÅ¼dy z nich ma ten sam cel:
ğŸ‘‰ utrzymaÄ‡ stan rzeczywisty = stan poÅ¼Ä…dany

PrzykÅ‚ad:
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: nginx
        image: nginx

Scenariusz:
DziaÅ‚ajÄ… 3 Pody.
Jeden Pod siÄ™ wysypuje.
ReplicaSet Controller wykrywa, Å¼e dziaÅ‚a tylko 2 Pody (stan aktualny â‰  poÅ¼Ä…dany).
Tworzy nowy Pod.
Znowu mamy 3 Pody â€” stan wyrÃ³wnany

----------------CONTAINER RUNTIME-----------------------------
CONTAINER RUNTIME - Uruchamia kontenery (Dockera) w nodach Kubernetesa. Za wÅ‚aÅ›ciwe utworzenie, uruchomienie, zatrzymanie 
czy usuniÄ™cie kontenerÃ³w odpowiada wÅ‚aÅ›nie container runtime. DziaÅ‚a na kaÅ¼dym Node w klastrze 
CRI (Container Runtime Interface)

Jak to dziaÅ‚a w praktyce?
1. Scheduler wybiera wÄ™zeÅ‚, na ktÃ³rym ma siÄ™ uruchomiÄ‡ Pod.
2. Kubelet na tym wÄ™Åºle pobiera definicjÄ™ Podâ€™a z API Servera.
3. Kubelet przekazuje polecenie do Container Runtime Interface (CRI).
4. Container Runtime:
- pobiera obraz kontenera z rejestru (np. Docker Hub, Harbor),
- tworzy kontener (czyli izolowane Å›rodowisko z sieciÄ…, systemem plikÃ³w, itp.),
- uruchamia go i monitoruje jego stan.
Kubelet nastÄ™pnie raportuje status kontenera z powrotem do API Servera.

PrzykÅ‚ad:
1. Tworzysz Deployment z obrazem:
containers:
  - name: nginx
    image: nginx:latest

2. Scheduler wybiera wÄ™zeÅ‚ node1.
3. Kubelet na node1 mÃ³wi do runtimeâ€™a (np. containerd):
â€Hej, uruchom mi kontener z obrazem nginx:latest.â€
4. Containerd:
- pobiera obraz z rejestru (jeÅ›li go nie ma),
- tworzy kontener,
- uruchamia proces nginx.
5. Kubelet raportuje do API Servera: â€Pod nginx dziaÅ‚a âœ…â€.

----------------kubelet-----------------------------
kubelet - jest agentem dziaÅ‚ajÄ…cym na kaÅ¼dym worker nodzie w klastrze, jest odpowiedzialny za upewnienie siÄ™, Å¼e kontenery dziaÅ‚ajÄ…. 
Uruchamia, restartuje i usuwa KONTENERY w Podach
kubelet dziaÅ‚a na kaÅ¼dym wÄ™Åºle (Node) klastra Kubernetes.
Bez niego Å¼aden Pod nie zostaÅ‚by faktycznie uruchomiony na wÄ™Åºle (Node).
Agent (proces), ktÃ³ry dziaÅ‚a na kaÅ¼dym wÄ™Åºle klastra i odpowiada za uruchamianie oraz monitorowanie kontenerÃ³w zgodnie z tym, 
co zleci control plane (API Server).
kubelet to â€straÅ¼nik wÄ™zÅ‚aâ€, ktÃ³ry:
- odbiera polecenia od Kubernetes API Servera,
- uruchamia kontenery poprzez Container Runtime (np. containerd, CRI-O),
- pilnuje, Å¼eby wszystko dziaÅ‚aÅ‚o tak, jak opisano w manifestach (YAML-ach).

Tworzy i uruchamia Pody:
Kiedy kubelet dostaje informacjÄ™, Å¼e ma uruchomiÄ‡ Pod:
- pobiera definicjÄ™ kontenerÃ³w,
- przekazuje jÄ… do Container Runtime Interface (CRI),
- a ten faktycznie uruchamia kontenery.

Monitoruje stan kontenerÃ³w
Kubelet ciÄ…gle sprawdza, czy kontenery:
- dziaÅ‚ajÄ…,
- nie zuÅ¼ywajÄ… za duÅ¼o zasobÃ³w,
- nie padÅ‚y (jeÅ›li padÅ‚y â€” moÅ¼e je uruchomiÄ‡ ponownie).
JeÅ›li coÅ› siÄ™ zmienia, kubelet raportuje status do API Servera.

PrzykÅ‚ad dziaÅ‚ania w praktyce:
1. Tworzysz Deployment:
replicas: 3
containers:
  - name: nginx
    image: nginx

2. Scheduler wybiera wÄ™zeÅ‚ node1 dla jednego z PodÃ³w.
3. API Server przekazuje kubeletowi na node1, Å¼e ma uruchomiÄ‡ ten Pod.
4. Kubelet:
- pobiera obraz nginx przez containerd,
- uruchamia kontener,
- montuje potrzebne zasoby (sieÄ‡, wolumeny),
- monitoruje jego dziaÅ‚anie.
5. JeÅ›li kontener siÄ™ wysypie â€” kubelet go automatycznie restartuje.

----------------kubectl-----------------------------
kubectl (kube) - commandline, narzÄ™dzie wiersza poleceÅ„ kube. NarzÄ™dzie to sÅ‚uÅ¼y do wdraÅ¼ania i zarzÄ…dzania aplikacjami w klastrze Kubernetes. 
Aby uzyskaÄ‡ informacje o klastrze, statusie nodÃ³w itp. 

dzie kubectl trzyma konfiguracjÄ™?
kubectl korzysta z pliku konfiguracyjnego:
~/.kube/config

Komendy:
kubectl run hello-minikube
kubectl cluster-info
kubectl get nodes

Master vs Worker Node
__________________
      Master      |    
</>kube-apiserver |
etcd              |
controller        |
scheduler         |
__________________|
*Master Node
__________________
      Node        |    
</>kubelet        |
Kontainer Runtime |
--------------    |
*Kubernetes       |
__________________|
*Worker node

----------------------------------------------------------------------------------
PrzykÅ‚ad dziaÅ‚ania wszystkich komponentÃ³w na przykÅ‚adzie uruchomienia nowego Podâ€™a:

Tworzysz aplikacjÄ™ nginx â€” czyli wykonujesz:
kubectl apply -f nginx.yaml

Krok 1. kubectl â†’ API Server
UÅ¼ytkownik wysyÅ‚a Å¼Ä…danie przez kubectl do API Servera (np. REST POST z definicjÄ… Podâ€™a).
API Server:
- sprawdza uprawnienia (RBAC),
- waliduje manifest YAML,
- zapisuje definicjÄ™ Podâ€™a w bazie etcd.

Stan etcd po tym kroku:
Etcd zawiera informacjÄ™: â€Powinien istnieÄ‡ Pod nginx (desired state), ale jeszcze nie jest uruchomiony.â€

Krok 2. Controller (control loop)
Controller Manager (konkretnie ReplicationController lub Deployment Controller) monitoruje zmiany przez API Server.
WidziaÅ‚ nowy obiekt Pod, wiÄ™c sprawdza: czy Pod istnieje fizycznie w klastrze?
jeÅ›li nie â†’ naleÅ¼y go utworzyÄ‡.
Controller niczego nie uruchamia sam â€” tylko aktualizuje status Podâ€™a w API Serverze:
dodaje wpis: â€Pod oczekuje na przypisanie wÄ™zÅ‚a (nodeName = null)â€.

Krok 3. Scheduler obserwuje API Server i widzi nowy Pod bez przypisanego nodeName.
Scheduler:
- analizuje dostÄ™pne wÄ™zÅ‚y (Nodeâ€™y),
- sprawdza zasoby, affinity, tainty itp.,
- wybiera najlepszy wÄ™zeÅ‚ (np. node1).
NastÄ™pnie aktualizuje Pod w API Serverze â€” dodaje Node

Krok 4. Kubelet widzi nowy Pod przypisany do node1.
Pobiera jego specyfikacjÄ™ i przekazuje do Container Runtime Interface (CRI).

Krok 5. Container Runtime uruchamia kontenery
pobiera obraz nginx:latest z rejestru,
tworzy i uruchamia kontener w izolowanym Å›rodowisku,
Po uruchomieniu, runtime zgÅ‚asza kubeletowi, Å¼e kontener dziaÅ‚a.

Krok 6. kubelet raportuje do API Servera
Kubelet aktualizuje status Podâ€™a w API Serverze:
status:
  phase: Running
  conditions:
    - Ready: true
API Server zapisuje nowy stan w etcd

Krok 7. Kontrola ciÄ…gÅ‚a (Controller Loop)
JeÅ›li kontener padnie, kubelet zgÅ‚asza to do API Servera.
Controller zauwaÅ¼a, Å¼e â€stan aktualny â‰  stan poÅ¼Ä…danyâ€ i moÅ¼e wymusiÄ‡ jego ponowne utworzenie.
Proces zaczyna siÄ™ od nowa â€” to wÅ‚aÅ›nie mechanizm self-healing.

Diagram:
[ YOU ] 
   â”‚
   â–¼
[kubectl] â”€â”€â”€â–¶ [API Server] â”€â”€â”€â–¶ [etcd]
                     â”‚
                     â–¼
           [Controller Manager]
                     â”‚
                     â–¼
               [Scheduler]
                     â”‚
             (przypisuje node)
                     â–¼
               [Kubelet na Node1]
                     â”‚
                     â–¼
             [Container Runtime]
                     â”‚
                     â–¼
                (Kontener dziaÅ‚a)
WyobraÅº sobie, Å¼e Kubernetes to fabryka:

Element	/ Odpowiednik w fabryce
kubectl	/ Kierownik zleca nowe zadanie (â€ZrÃ³b 3 Nginxyâ€)
API Server	/ Recepcja, ktÃ³ra przyjmuje zlecenie i zapisuje je w systemie
etcd	/ Baza danych z listÄ… wszystkich zadaÅ„
Scheduler	/ Planista decyduje, ktÃ³ra maszyna wykona dane zadanie
Controller	/ Nadzorca, ktÃ³ry pilnuje, Å¼e wszystko siÄ™ zgadza
Kubelet	/ Operator maszyny wykonujÄ…cej pracÄ™
Container / Runtime	Sama maszyna, ktÃ³ra faktycznie tworzy produkt (kontener)
